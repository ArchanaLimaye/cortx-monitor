#!/usr/bin/python2.7
# -*- coding: utf-8 -*-

"""
 ****************************************************************************
 Filename:          sspl_ll_d
 Description:       Entry point for the sspl-ll daemon service
 Creation Date:     01/14/2015
 Author:            Jake Abernathy

 Do NOT modify or remove this copyright and confidentiality notice!
 Copyright (c) 2001 - $Date: 2015/01/14 $ Seagate Technology, LLC.
 The code contained herein is CONFIDENTIAL to Seagate Technology, LLC.
 Portions are also trade secret. Any use, duplication, derivation, distribution
 or disclosure of this code, for any reason, not expressly authorized is
 prohibited. All other rights are expressly reserved by Seagate Technology, LLC.
 ****************************************************************************
"""

import logging
import daemon
import signal
import getopt
import Queue
import time
import sys
import os

from daemon.pidfile import PIDLockFile
from threading import Thread

# Add the top level directories
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
os.sys.path.insert(0,parentdir)

from utils.config_reader import ConfigReader
from utils.service_logging import init_logging
from utils.service_logging import logger

# Modules for handling RabbitMQ messages and manipulating internal threads
from rabbitmq.rabbitmq_egress_processor import RabbitMQegressProcessor 
from rabbitmq.rabbitmq_ingress_processor import RabbitMQingressProcessor 
from rabbitmq.logging_processor import LoggingProcessor
from rabbitmq.thread_controller import ThreadController

# Modules for handling specific JSON messages
from message_handlers.drive_manager_monitor import DriveManagerMonitor
from message_handlers.logging_msg_handler import LoggingMsgHandler
from message_handlers.systemd_msg_handler import SystemdMsgHandler

# Message to send to HAlon upon critical thread errors
from json_msgs.messages.actuators.thread_controller import ThreadControllerMsg


# Section and key in config file for bootstrap
SSPL_SETTING  = 'SSPL-LL_SETTING'
MODULES       = 'modules'

# Instantiate the internal ThreadController. Global so the shutdown callback
#  method can use it to properly halt all running threads.
threadController = ThreadController()

def main(conf_reader):
    """The main bootstrap for sspl"""
    logger.info("sspl-ll Bootstrap: Obtaining list of modules from config file")
    conf_modules = conf_reader._get_value_list(SSPL_SETTING,
                                                MODULES)
    logger.info("sspl-ll Bootstrap: Modules to load: %s" % conf_modules)

    # Create a map of references to all the module's message queues.  Each module
    #  is passed this mapping so that it can send messages to other modules.
    msgQlist = {}

    # Create a mapping of all the instantiated modules to their names
    sspl_modules = {}

    # Use reflection to instantiate the class based upon its class name in config file
    for conf_thread in conf_modules:
        klass = globals()[conf_thread]

        # Create mappings of modules and their message queues
        sspl_modules[klass.name()] = klass()
        msgQlist[klass.name()] = Queue.Queue()

    msgQlist[ThreadController.name()] = Queue.Queue()

    try:
        # Loop through the list of instanced modules and start them on threads
        for name, curr_module in sspl_modules.iteritems():
            logger.info("Starting %s" % curr_module.name())
            thread = Thread(target=_run_thread_capture_errors,
                            args=(curr_module, sspl_modules, msgQlist, conf_reader))
            thread.start()

        # Start the ThreadController module with the list of threads
        logger.info("Starting %s" % ThreadController.name())

        # Initialize the thread controller with the list of references to all modules
        controller_thread = Thread(target=_run_thread_capture_errors,
                            args=(threadController, sspl_modules, msgQlist, conf_reader))
        threadController.initialize_thread_list(sspl_modules)
        controller_thread.start()

        startup_msg = "SSPL-LL service has started successfully"
        jsonMsg   = ThreadControllerMsg(threadController.name(), startup_msg).getJson()
        threadController._write_internal_msgQ(RabbitMQegressProcessor.name(), jsonMsg)   

        # Block main thread until thread controller has been halted
        controller_thread.join()

    except Exception as ex:
        logger.exception(ex)

def _run_thread_capture_errors(curr_module, sspl_modules, msgQlist, conf_reader):
    """Run the given thread and log any errors that happen on it.
    Will stop all sspl_modules if one of them fails."""
    try:
        # Each module is passed a reference list to message queues so it can transmit
        #  internal messages to other modules as desired
        curr_module.initialize(conf_reader, msgQlist)
        curr_module.start()

    except Exception as ex:
        # Populate an actuator response message and transmit back to HAlon
        error_msg = "SSPL-LL encountered an error, terminating service Error: " + \
                    + e + ", Exception: " + logger.exception()
        jsonMsg   = ThreadControllerMsg(curr_module.name(), error_msg).getJson()
        curr_module._write_internal_msgQ(RabbitMQegressProcessor.name(), jsonMsg)

        # Shut it down, error is non-recoverable
        for name, other_module in sspl_modules.iteritems():
            if other_module is not curr_module:
                other_module.shutdown()

def shutdown_handler(signum, stackframe):
    """Handler called when shutting down a=None, b=None"""
    logger.info("sspl-ll is shutting down")
    shutdown_msg = "SSPL-LL is shutting down"
    jsonMsg   = ThreadControllerMsg(threadController.name(), shutdown_msg).getJson()
    threadController._write_internal_msgQ(RabbitMQegressProcessor.name(), jsonMsg)

    # Wait for the RabbitMQegressProcessor to finish processing
    #  any messages which it may have in its queue
    while threadController.check_RabbitMQegressProcessor_busy() is True:
        timer.sleep(2)

    # Now call the shutdown methods for all modules to gracefully halt
    threadController.shutdown_all_modules()

    # Halt the thread controller module last for a clean system shutdown
    threadController.shutdown()

def print_usage():
    """Display the syntax usage for this script"""
    print """sspl_ll_d -c <path_to_conf_file>
    -h:    Display this help
    -c:    Configuration settings for sspl_ll_d service"""


if __name__ == "__main__":
    # Retrieve configuration file for sspl-ll service
    try:
        opts = getopt.getopt(sys.argv[1:], "hc:", ["help", "config="])

    except getopt.GetoptError as err:
        print_usage()
        sys.exit(os.EX_USAGE)

    if len(opts[0]) < 1:
        print_usage()
        sys.exit(os.EX_USAGE)

    for opt, arg in opts[0]:
        if opt == "-c" or opt == "--config":
            path_to_conf_file = arg
        else:
            print_usage()
            sys.exit(os.EX_USAGE)

    # Validate configuration file for required valid values
    try:
        conf_reader = ConfigReader(path_to_conf_file)
        conf_reader.validate_config_file()

    except (IOError, ConfigReader.Error) as err:
        # We don't have logger yet, need to find log_level from conf file first
        print "[ Error ] when validating the configuration file %s :" % \
            path_to_conf_file
        print err
        print "Exiting ..."
        exit(os.EX_USAGE)

    # Initialize logging
    try:             
        init_logging("SSPL-LL", "DEBUG")

    except Exception as err:
        # We don't have logger since it threw an exception, use generic 'print'
        print "[ Error ] when initializing logging :"
        print err
        print "Exiting ..."
        exit(os.EX_USAGE)

    try:
        context = daemon.DaemonContext()

        # Configure a shutdown handler to handle any necessary cleanup
        context.signal_map = {signal.SIGTERM: shutdown_handler}
        context.open()

        # Start sspl-ll as a main process running multiple threads
        with context:
            main(conf_reader)

    except (Exception, StandardError) as err:
        logger.critical("While spawning sspl-ll process :%r" % err)
        logger.exception()
        sys.exit(os.EX_USAGE)

    print "SSPL-LL Process started successfully"
    sys.exit(os.EX_OK)
