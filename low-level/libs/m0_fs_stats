#!/usr/bin/env python

from __future__ import print_function  # print to sys.stderr
import sys
import atexit
from subprocess import Popen, PIPE
from mero import *
from ctypes import *

def address_get():
    try:
        p = Popen(['lctl', 'list_nids'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        output, err = p.communicate()
    except OSError:
        return ''
    # When the tool is executing without sudo privileges (i. e. with "--help"
    # option) then lctl output will be an empty string)
    return output.split()[0] if output else ''

def require(**params):
    def check_types(func, params=params):
        def modified(*args, **kw):
            arg_names = func.func_code.co_varnames
            kw.update(zip(arg_names, args))
            for name, type in params.iteritems():
                param = kw[name]
                param_valid = param is None or isinstance(param, type)
                if not param_valid:
                    raise TypeError("Parameter '{0}' should be of type '{1}'"
                                    .format(name, type.__name__))
            return func(**kw)
        return modified
    return check_types

# struct m0_fid
class Fid(Structure):
    _fields_ = [("f_container", c_uint64), ("f_key", c_uint64)]

    def __str__(self):
        return "<" + hex(self.f_container)[:-1] + ":" + str(self.f_key) + ">"

spiel_rms_fid = Fid(0x7300000000000004, 100)

# struct m0_net_xprt
class NetXprt(Structure):
    _fields_ = [('nx_name', c_char_p), ('nx_ops', c_void_p)]

#struct m0_reqh_init_args
class ReqhInitArgs(Structure):
    _fields_ = [('rhia_dtm', c_void_p), ('rhia_db', c_void_p),
                ('rhia_mdstore', c_void_p), ('rhia_pc', c_void_p),
                ('rhia_fid', POINTER(Fid))]

class FsStats(Structure):
    _fields_ = [('fs_free', c_uint64),
                ('fs_total', c_uint64)]

def call(func, *args):
    rc = func(*args)
    if rc != 0:
        raise RuntimeError('%s() failed, rc=%d' % (func.__name__, rc))


class SpielWrapper:
    def __init__(self, mero_path, client_ep, ha_ep):
        self.mero = CDLL(mero_path)
        self.mero.malloc.restype = c_void_p

        self.client_ep = c_char_p(client_ep)
        self.ha_ep = c_char_p(ha_ep)

        self.spiel       = None
        self.ha_session  = None
        self.ha_conn     = None
        self.rpc_machine = None
        self.reqh        = None
        self.buffer_pool = None
        self.domain      = None
        self.m0          = None

    def spiel_init(self):
        try:
            self.__m0_init()
            self.__net_domain_init()
            self.__net_buffer_pool_setup()
            self.__reqh_setup()
            self.__rpc_machine_init()
            self.__ha_session_init()
            self.__spiel_init()
        except Exception as ae:
            print('An error occurred: ' + str(ae), file=sys.stderr)

    def spiel_fini(self):
        """Clean up and free mem"""
        if self.spiel:
            self.mero.m0_spiel_fini(self.spiel)
            self.__free(self.spiel)

        if self.ha_session:
            self.mero.m0_ha_state_fini()
            self.mero.m0_rpc_session_destroy(self.ha_session, ~0L)
            self.__free(self.ha_session)

        if self.ha_conn:
            self.mero.m0_rpc_conn_destroy(self.ha_conn, ~0L)
            self.__free(self.ha_conn)

        if self.rpc_machine:
            self.mero.m0_rpc_machine_fini(self.rpc_machine)
            self.__free(self.rpc_machine)

        if self.reqh:
            self.mero.m0_reqh_services_terminate(self.reqh);
            self.mero.m0_reqh_fini(self.reqh)
            self.__free(self.reqh)

        if self.buffer_pool:
            self.mero.m0_rpc_net_buffer_pool_cleanup(self.buffer_pool)
            self.__free(self.buffer_pool)

        if self.domain:
            self.mero.m0_net_domain_fini(self.domain)
            self.__free(self.domain)

        if self.m0:
            self.mero.m0_fini(self.m0)
            self.__free(self.m0)

    def rconfc_start(self):
        return self.mero.m0_spiel_rconfc_start(self.spiel)

    def rconfc_stop(self):
        self.mero.m0_spiel_rconfc_stop(self.spiel)

    @require(profile=str)
    def cmd_profile_set(self, profile):
        return self.mero.m0_spiel_cmd_profile_set(self.spiel, profile)

    @require(fid=Fid, stats=FsStats)
    def filesystem_stats_fetch(self, fid, stats):
        return self.mero.m0_spiel_filesystem_stats_fetch(self.spiel,
                                                         byref(fid),
                                                         byref(stats))

    def __m0_init(self):
        m0 = self.__malloc(m0__size())
        call(self.mero.m0_init, m0)
        self.m0 = m0

    def __net_domain_init(self):
        domain = self.__malloc(m0_net_domain__size())
        xprt = NetXprt.in_dll(self.mero, 'm0_net_lnet_xprt')
        call(self.mero.m0_net_domain_init, domain, pointer(xprt))
        self.domain = domain

    def __net_buffer_pool_setup(self):
        buffer_pool = self.__malloc(m0_net_buffer_pool__size())
        call(self.mero.m0_rpc_net_buffer_pool_setup, self.domain, buffer_pool,
            c_uint32(2), # nr bufs
            c_uint32(1)) # nr TMs
        self.buffer_pool = buffer_pool

    def __reqh_setup(self):
        reqh = self.__malloc(m0_reqh__size())
        reqh_args = ReqhInitArgs()

        reqh_args.rhia_fid = pointer(Fid(0x7200000000000001, 5)) # process-5

	reqh_args.rhia_dtm = 1
        reqh_args.rhia_mdstore = 1 # dummy value

        call(self.mero.m0_reqh_init, reqh, byref(reqh_args))
        self.__free(reqh_args)
        self.mero.m0_reqh_start(reqh)
        rms = self.__malloc(m0_reqh_service__size())
        rms_p = cast(rms, c_void_p)
        call(self.mero.m0_reqh_service_setup, rms_p, self.mero.m0_rms_type,
             reqh, None, byref(spiel_rms_fid))
        self.reqh = reqh

    def __rpc_machine_init(self):
        rpc_machine = self.__malloc(m0_rpc_machine__size())
        call(self.mero.m0_rpc_machine_init, rpc_machine, self.domain,
             self.client_ep, self.reqh, self.buffer_pool,
             c_uint(~0),      # M0_BUFFER_ANY_COLOUR
             c_uint(1 << 17), # M0_RPC_DEF_MAX_RPC_MSG_SIZE (128 KB)
             c_uint(2))       # M0_NET_TM_RECV_QUEUE_DEF_LEN
        self.rpc_machine = rpc_machine

    def __ha_session_init(self):
        self.ha_conn = self.__malloc(m0_rpc_conn__size())
        self.ha_session = self.__malloc(m0_rpc_session__size())
        call(self.mero.m0_rpc_client_connect, self.ha_conn, self.ha_session,
             self.rpc_machine, self.ha_ep, None,
             2) # max_rpcs_in_flight
        self.mero.m0_ha_state_init(self.ha_session)

    def __spiel_init(self):
        spiel = self.__malloc(m0_spiel__size())
        call(self.mero.m0_spiel_init, spiel, self.reqh)
        self.spiel = spiel

    def __malloc(self, size):
        ptr = self.mero.malloc(size) # XXX Why don't we use m0_alloc()?
        memset(ptr, 0, size)
        return ptr

    def __free(self, ptr):
        self.mero.free(ptr)


if __name__ == "__main__":
    try:
        # Get the arguments passed in
        cmd_list = sys.argv

        # Get the nid and use it to create endpoints for mero client and halon ha
        addr = address_get()
        libmero_path = cmd_list[1]
        ha_ep        = "{}:{}".format(addr, cmd_list[2])
        client_ep    = "{}:{}".format(addr, cmd_list[3])
        fs_fid_key   = cmd_list[4]

        #print("libmero_path: {}, client_ep: {}, ha_ep: {}, fs fid key: {}" \
        #      .format(libmero_path, client_ep, ha_ep, fs_fid_key))

        spiel = SpielWrapper(libmero_path, client_ep, ha_ep)
        atexit.register(spiel.spiel_fini)

        spiel.spiel_init()
        spiel.cmd_profile_set("0x7000000000000001:0x1")
        spiel.rconfc_start()

        fs_stats = FsStats()
        fid = Fid(0x6600000000000001, int(fs_fid_key))
        spiel.filesystem_stats_fetch(fid, fs_stats)

        print("total space: {}, free space: {}".format(fs_stats.fs_total, fs_stats.fs_free))
        spiel.rconfc_stop()

    except RuntimeError as e:
        print('An error occurred: ' + str(e), file=sys.stderr)