#!/usr/bin/env python 
# encoding: utf-8
"""
 Filename:          sspl-ll-cli
 Description:       CLI to send msgs to SSPL-LL service
 Creation Date:     12/02/2015
 Author:            Jake Abernathy

 Do NOT modify or remove this copyright and confidentiality notice!
 Copyright (c) 2001 - $Date: 2015/01/14 $ Seagate Technology, LLC.
 The code contained herein is CONFIDENTIAL to Seagate Technology, LLC.
 Portions are also trade secret. Any use, duplication, derivation, distribution
 or disclosure of this code, for any reason, not expressly authorized is
 prohibited. All other rights are expressly reserved by Seagate Technology, LLC.
"""

import subprocess
import sys
import os
import re
import json
import time
from json import JSONDecoder

# Add the top level directories
sys.path.insert(0, '/opt/seagate/sspl/low-level')
from framework.utils.config_reader import ConfigReader
from tests.manual.manual_test import ManualTest

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

__all__ = []
__version__ = 0.2
__date__ = '2015-12-02'
__updated__ = '2016-5-02'

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# Create instance of ManualTest to publish messages
manTest = ManualTest("RABBITMQEGRESSPROCESSOR")    

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg

    def __str__(self):
        return self.msg

    def __unicode__(self):
        return self.msg

def main():
    '''CLI to send msgs to SSPL-LL service'''

    # Display help if no args are passed in
    if len(sys.argv) == 1:
        sys.argv.append("--help")

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)
    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    description = "Program for interacting with SSPL-LL service"

    try:
        # Setup argument parser
        parser = ArgumentParser(description=description, formatter_class=RawDescriptionHelpFormatter, add_help=False)
        parser.add_argument("-v", "--version", action="version", version=program_version_message)
        parser.add_argument("-a", "--all", action="store_true", help="display all the data received in responses")
        parser.add_argument("-h", "--human", action="store_true", help="display responses with indentation for readability")
        parser.add_argument("--help", action="store_true", help="display this help message and exit")
        parser.add_argument("--generic", metavar="COMMAND", help="execute from command line ie 'SWAP ON'")
        parser.add_argument("--pdu", metavar="COMMAND", help="send command to PDU. \
                              ie 'show outlets details'")
        parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
        parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
        parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
        parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
        parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
        parser.add_argument("--hdparm", metavar="COMMAND", help="ie \"-I /dev/sda | grep 'Serial Number:'\"")
        parser.add_argument("--iemlog", metavar="MESSAGE", help="IEM log.  ie 'IEC: 001002001: Rules Engine...'")
        parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")
        parser.add_argument("--iemhost", metavar="HOST", help="IEM receiver. ie 10.22.192.100, default localhost")
        parser.add_argument("--iemexchange", metavar="EXCHNG", help="RabbitMQ exchange. ie sspl_iem, default sspl_halon")
        parser.add_argument("--fsstats", metavar="FSFIDKEY", help="display total/free space on Mero, ie --fsstats 4")

        group = parser.add_mutually_exclusive_group()
        group.add_argument("--smrdata", action="store_true", help="log SMR drive register data")
        group.add_argument("--cpudata", action="store_true", help="display CPU data")
        group.add_argument("--hostdata", action="store_true", help="display host data")
        group.add_argument("--mountdata", action="store_true", help="display local mount data")
        group.add_argument("--interfacedata", action="store_true", help="display network interface data")
        group.add_argument("--raiddata", action="store_true", help="display RAID data")

        parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
        parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")

        parser.add_argument("--stopdrive", metavar="DRIVE", help="power down a drive.  ie /dev/sda1")
        parser.add_argument("--startdrive", metavar="DRIVE", help="power up a drive.  ie /dev/sda1")
        parser.add_argument("--resetdrive", metavar="DRIVE", help="reset drive by cycling its power.  ie /dev/sda1")
        parser.add_argument("--smart", metavar="DRIVE", help="schedule a SMART test on a drive. ie /dev/sda1 or '*'")
        parser.add_argument("--drvmngr", metavar="DRIVE", help="display drivemanager's status. ie /dev/sda1 or '*'")
        parser.add_argument("--hpi", metavar="DRIVE", help="display HPI status. ie /dev/sda1 or '*'")
        parser.add_argument("--setdrivestatus", metavar="DRIVE --status [STATUS] --reason [REASON]",
                            help="set status and reason of a drive. ie /dev/sda1 or " \
                            "s/n, --status STATUS --reason REASON")
        parser.add_argument("--status", metavar="STATUS", help="set the status field used in --setdrivestatus")
        parser.add_argument("--reason", metavar="REASON", help="set the reason field used in --setdrivestatus")

        parser.add_argument("--setdriveLED", metavar="DRIVE --LEDstate [LEDSTATE]",
                            help="set LED state of a drive. ie /dev/sda1 or " \
                            "s/n, --LEDstate LEDSTATE")
        parser.add_argument("--getdriveLED", metavar="DRIVE",
                            help="get LED state of a drive. ie /dev/sda1 or s/n")
        parser.add_argument("--LEDstate", metavar="LEDSTATE", help="FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF,"\
                            "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
        group.add_argument("--expreset", action="store_true", help="trigger expander reset")
        parser.add_argument("--simulate", metavar="IDENTIFIER --event [EVENT]",
                            help="simulate an event. ie /dev/sda1 or s/n " \
                            "--event EVENT")
        parser.add_argument("--event", metavar="EVENT", help="DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET " \
                            "ie --simulate all-drives --event EXP_RESET")

        # Process arguments
        args = parser.parse_args()

        if args.help:
            parser.print_help()

        elif args.pdu:
            # Load a PDU message from the manual tests directory and update it with args.pdu
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_pdu.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"PDU: {}".format(args.pdu)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, force_wait=True, response_wait_time=30)

        elif args.generic:
            # Load a generic SSPL message from the manual tests directory and update it with args.generic
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_sspl.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SSPL: {}".format(args.generic)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.stopdrive:
            # Load a stop drive message from the manual tests directory and update it with args.stopdrive
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_stop_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"STOP_DRIVE: {}".format(args.stopdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.startdrive:
            # Load a start drive message from the manual tests directory and update it with args.startdrive
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_start_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"START_DRIVE: {}".format(args.startdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.resetdrive:
            # Load a reset drive message from the manual tests directory and update it with args.resetdrive
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_reset_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"RESET_DRIVE: {}".format(args.resetdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.smart:
            # Load a smart test message from the manual tests directory and update it with args.smart
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_smart_test.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SMART_TEST: {}".format(args.smart)

            print("\nInitiating SMART tests.  This can take several minutes...\n")
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=300,
                          force_wait=True)

        elif args.drvmngr:
            # Load a drivemanager status message from the manual tests directory and update it with args.drvmngr
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_drvmngr_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"DRVMNGR_STATUS: {}".format(args.drvmngr)

            force_wait = False
            wait_time = 3
            if "*" in str(args.drvmngr):
                wait_time = 30
                force_wait = True

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif args.hpi:
            # Load a reset hpi status message from the manual tests directory and update it with args.hpi
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_hpi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"HPI_STATUS: {}".format(args.hpi)

            force_wait = False
            wait_time = 3
            if "*" in str(args.hpi):
                wait_time = 30
                force_wait = True

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif args.getdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args.getdriveLED
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"LED: get {}".format(args.getdriveLED)

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif args.setdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args 
            if not args.LEDstate:
                print("Error: must provide a LED state --LEDstate LEDSTATE when using --setdriveLED")
                return

            if args.LEDstate not in ["FAULT_ON", "FAULT_OFF", "IDENTIFY_ON", 
                                     "IDENTIFY_OFF", "PULSE_SLOW_ON", "PULSE_SLOW_OFF", 
                                     "PULSE_FAST_ON", "PULSE_FAST_OFF"]:
                print("Possible LED states: FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF," \
                      "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
                return

            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"LED: set {} {}" \
                        .format(args.setdriveLED, args.LEDstate)

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif args.simulate:
            # Load a node controller SIM message from the manual tests directory and update it with args 
            if not args.event:
                print("Error: must provide an event to simulate --event EVENT when using --simulate")
                return

            if args.event not in ["DRIVE_INSTALL", "DRIVE_UNINSTALL", "EXP_RESET"]:
                print("Possible simulated EVENTS: DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET")
                return

            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_simulate_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SIMULATE: {} {}" \
                        .format(args.event, args.simulate)

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif args.setdrivestatus:
            # Load a HDS logging message from the manual tests directory and update it with args 
            if not args.status:
                print("Error: must provide a status --status STATUS when using --setdrivestatus")
                return

            if not args.reason:
                print("Error: must provide a reason --reason REASON when using --setdrivestatus")
                return

            drive = str(args.setdrivestatus)
            status = str(args.status)
            reason = str(args.reason)

            if drive.startswith("/"):
                print("Retrieving serial number using device name with hdparm tool")
                # Build the desired command using hdparm tool
                command = "/usr/sbin/hdparm -I {} | grep 'Serial Number:'".format(drive)
                print("executing command: %s" % command)

                # Run the command and get the response and error returned
                process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                hdparm_response, error = process.communicate()

                # If an error exists stop here and return the response
                if error:
                    drive = "FAKE_TEST_SN"
                    print("Failed to lookup s/n: {}".format(error))
                    print("Ignoring and using a test s/n: %s" % drive)
                else:
                    # Parse out "Serial Number:" from hdparm result to obtain serial number
                    drive = hdparm_response[15:].strip()
                    print("Successfully retrieved s/n: %s" % drive)

            log_msg = "IEC: 038001001: Halon Disk Status: {'status': '%s', 'reason': '%s'," \
                        "'serial_number': '%s'}" % (status, reason, drive)
            print("log_msg: %s" % log_msg)

            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/HDS_logging.json"
            jsonMsg = json.loads(open(file).read())

            print("    log_msg: %s" % log_msg)
            jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = u"{}".format(log_msg)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.restartthread:
            # Load a restart thread message from the manual tests directory and update it with args.restartthread
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = u"{}".format(args.restartthread)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.servicename or args.servicereq:
            if not args.servicename:
                print("Error: must provide a service name to apply request using --servicename NAME")
                return

            if not args.servicereq:
                print("Error: must provide a request to apply to the service using --servicereq REQUEST")
                print("       where REQUEST must be one of: start/stop/restart/status/enable/disable")
                return

            if args.servicereq not in ['start', 'stop', 'restart', 'status', 'enable', 'disable']:
                print("Error: Service request must be one of: start/stop/restart/status/enable/disable")
                return

            if ".service" not in args.servicename:
                args.servicename += ".service"

            # Load a service controller message from the manual tests directory and update it with args.servicename & servicereq
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/service_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_name"] = u"{}".format(args.servicename)
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_request"] = u"{}".format(args.servicereq)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.ipmicmd or args.ipmiIP:
            if not args.ipmiIP:
                print("Error: must provide an IP to apply using --ipmiIP IP")
                return

            if args.ipmicmd not in ['on', 'off', 'cycle', 'status']:
                print("Error: IPMI command must be one of: on/off/cycle/status")
                return

            # Load a IPMI command message from the manual tests directory and update it with args.ipmicmd & ipmiIP
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_ipmi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"IPMI: {} {}". \
                                    format(args.ipmiIP, args.ipmicmd)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.hdparm:
            # Load a hdparm message from the manual tests directory and update it with args.hdparm
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_hdparm.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"HDPARM: {}".\
                                    format(args.hdparm)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.iemlog or args.iemloglevel:
            if not args.iemlog:
                print("Error: must provide an IEM message using --iemlog MESSAGE")
                return
 
            if not args.iemloglevel:
                print("Error: must provide a log level to apply using --iemloglevel LEVEL")
                print("       where LEVEL is one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,") 
                print("                              LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if args.iemloglevel not in ['LOG_EMERG', 'LOG_ALERT', 'LOG_CRIT', 'LOG_ERR', \
                                        'LOG_WARNING', 'LOG_NOTICE', 'LOG_INFO', 'LOG_DEBUG']:
                print("Error: IEM log level must be one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, ")
                print("                                  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if "IEC" not in args.iemlog:
                print("Error: IEM log must be in form: 'IEC: xxxxxxxx: {JSON data}")
                return

            # Default to standard json format with typical headers
            if not args.iemexchange:
                # Load a logging message from the manual tests directory and update it with args.iemlog
                file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/logging.json"
                jsonMsg = json.loads(open(file).read())
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_level"] = u"{}".\
                                                            format(args.iemloglevel)
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = u"{}".\
                                                            format(args.iemlog)
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, 
                              wait_for_response=False, host=args.iemhost)
            else:
                log_msg = "{} {}".format(args.iemloglevel, args.iemlog)
                _send_iem_exchange(args.iemexchange, log_msg, host=args.iemhost)

        elif args.smrdata:
            # Load a restart thread message from the manual tests directory and update it with SMRdriveData
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = u"SMRdriveData"
            _send_raw_msg(jsonMsg, wait_for_response=False, alldata=args.all, indent=args.human)
            print("Check logs for new SMR drive register values")

        elif args.fsstats:
            # Load a node controller mero message and update it
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_mero.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = \
                    u"MERO: fsstats {}".format(args.fsstats)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif args.cpudata:
            # Load a sensor request message for cpu data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_cpu_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.hostdata:
            # Load a sensor request message for host data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_host_update.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.mountdata:
            # Load a sensor request message for local mount data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_mount_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.interfacedata:
            # Load a sensor request message for network data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_if_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.raiddata:
            # Load a sensor request message for raid data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_raid_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.expreset:
            # Trigger expander reset

            # Get the SG device
            command = "ls /sys/class/enclosure/*/device/scsi_generic"

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()

            sg_dev = "/dev/{}".format(response.rstrip('\n'))
            command = "wbcli {} reboot".format(sg_dev)

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()
            if error:
                print("Error triggering expander reset: %s" % str(error))
            if response:
                print("Triggering expander reset: %s" % str(response))

        elif args.fromstdin:
            print("Ctrl-D stop reading from stdin and transmit.  Multiple msgs can be piped in.")
            json_txt = ""
            try:
                json_txt = sys.stdin.read()
            except KeyboardInterrupt:
                pass

            if not json_txt:
                return 0

            # Load in a multiple json msgs possibly sent in from stdin
            json_list = []
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=WHITESPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        elif args.fromfile:
            # Load in a multiple json msgs stored in a single file
            json_list = []
            json_txt = open(args.fromfile).read()
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=WHITESPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        return 0
    except KeyboardInterrupt:
        return 0
    except Exception, e:
        print("Exception:{}".format(e))
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

def _send_raw_msg(jsonMsg, wait_for_response=True, response_wait_time=5,
                  alldata=False, indent=False, remove_results_file=True, 
                  host=None, force_wait=False):
    """Update authentication fields, validate and transmit json msg"""

    # Update the authentication fields in json msg
    manTest.addAuthFields(jsonMsg)

    # Validate the msg against the schemas
    manTest.validate(jsonMsg)

    # Encode and publish
    message = json.dumps(jsonMsg, ensure_ascii=True).encode('utf8')
    manTest.basicPublish(message=message, wait_for_response=wait_for_response, 
                         response_wait_time=response_wait_time, force_wait=force_wait,
                         alldata=alldata, indent=indent,
                         remove_results_file=remove_results_file,
                         host=host)

def _send_iem_exchange(exchange, log_msg, host=None):
    """Sends an IEM on a particular rabbitmq exchange"""
    try:
        # Raw IEM sent as a string with no header authentication fields or schema validation
        manTest.basicPublish(message=log_msg, wait_for_response=False, 
                             exchange=exchange, host=host)
    except Exception as ae:
        print "IEM failed on exchange: {}".format(exchange)
        print "Exception:{}".format(ae)

if __name__ == "__main__":
    sys.exit(main())
