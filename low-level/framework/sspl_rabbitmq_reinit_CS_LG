#!/usr/bin/env python
"""
Setup rabbitmq for use by sspl on CS-LG systems

This script uses /etc/sspl.conf as the source of the parameters.

Usage:
    ./sspl_rabbitmq_reinit_CS_LG
"""
import sys
import subprocess
import ConfigParser

RABBITMQCTL = '/usr/sbin/rabbitmqctl'
SSPL_CONF = '/etc/sspl.conf'
SECTION="PLANECNTRLRMQEGRESSPROCESSOR"


def main():
    """ Main line for this program. """
    config = ConfigParser.SafeConfigParser()
    config.read([SSPL_CONF])

    virtual_host = config.get(
        section=SECTION,
        option='virtual_host'
        )
    username = config.get(
        section=SECTION,
        option='username'
        )
    password = config.get(
        section=SECTION,
        option='password'
        )
    primary_rabbitmq_server = config.get(
        section=SECTION,
        option='primary_rabbitmq_server'
        )
    secondary_rabbitmq_server = config.get(
        section=SECTION,
        option='secondary_rabbitmq_server'
        )

    # Only apply rabbitmq config to mgmt nodes
    command = "hostname -A"
    hostnames = _send_command(command)
    if primary_rabbitmq_server not in hostnames and \
       secondary_rabbitmq_server not in hostnames:
        return

    # Reset if the node is down
    _check_rabbitmq_status()

    # Start rabbitmq-server
    _start_rabbitmq()

    # Create the vhost if it's not listed
    _create_vhost_if_necessary(virtual_host)

    # Create the user to access rabbitmq
    _create_user_if_necessary(username, password, virtual_host)

    # Copy the erlang key from primary server to secondary and mirror queues
    if primary_rabbitmq_server in hostnames:
        _set_perms_erlang_key()
        _copy_erlang_key(secondary_rabbitmq_server)
        _create_ha_queues()

    # Cluster the secondary server to the primary
    elif secondary_rabbitmq_server in hostnames:
        _set_perms_erlang_key()
        _cluster_rabbitmq_servers(primary_rabbitmq_server, secondary_rabbitmq_server)

def _create_vhost_if_necessary(virtual_host):
    """ Creates the specified vhost (if necessary).

    No action will occur if the vhost already exists.

    @type virtual_host:           string
    @param virtual_host:          The vhost to create.
    """
    command = "%s list_vhosts" % RABBITMQCTL
    response = _send_command(command, fail_on_error=False)
    # Try restarting service
    if "Error" in response:
        command = "service rabbitmq-server restart"
        _send_command(command)
        command = "%s list_vhosts" % RABBITMQCTL
        response = _send_command(command)

    vhosts = response.split('\n')
    assert vhosts[0] == 'Listing vhosts ...'
    for vhost in vhosts[1:-1]:
        if vhost == virtual_host:
            return

    command = "%s add_vhost %s" % (RABBITMQCTL, virtual_host)
    _send_command(command)
    print("Successfully created vhost: %s" % virtual_host)

def _create_user_if_necessary(username, password, virtual_host):
    """ Create the rabbitmq user (if necessary).

    The user is created (if it doesn't exist) and then set with .* permissions
    for conf,write,read on the specified virtual_host.

    The permissions will be set regardless of whether or not the user already exists.

    The password will only be set if this is a new user.

    Note: To delete the user, from bash, run::
        rabbitmqctl delete_user <username>

    @type username:               string
    @param username:              The user to create.
    @type password:               string
    @param passowrd:              The password for the specified user.  Will
                                  only be set if this is a new user.
    @type virtual_host:           string
    @param virtual_host:          The vhost on which the permissions will be
                                  set.
    """
    command = "%s list_users" % RABBITMQCTL
    response = _send_command(command)

    users = response.split("\n")
    assert users[0] == 'Listing users ...'
    found_user = False
    for userspec in users[1:-1]:
        user = userspec.split()[0]
        if user == username:
            found_user = True
            break
    if not found_user:
        # Create the user and set permissions, will exit upon error
        command = "%s add_user %s %s" % (RABBITMQCTL, username, password)
        _send_command(command)
        command = "%s set_permissions -p %s %s '.*' '.*' '.*'" % (RABBITMQCTL, virtual_host, username)
        _send_command(command)
        command = "%s set_user_tags %s administrator" % (RABBITMQCTL, username)
        _send_command(command)

def _check_rabbitmq_status():
    """Reset if the node is down"""
    command = "service rabbitmq-server status"
    response = _send_command(command)
    if "nodedown" in response:
        print("Nodedown, resetting")
        command = "pkill beam.smp"
        _send_command(command)

def _start_rabbitmq():
    """Ensure rabbitmq-server is started"""
    command = "service rabbitmq-server start"
    _send_command(command)

def _set_perms_erlang_key():
    # Set the ownership and permissions on cluster key
    command = "chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie"
    _send_command(command)
    command = "chmod 400 /var/lib/rabbitmq/.erlang.cookie"
    _send_command(command)

def _copy_erlang_key(secondary_rabbitmq_server):
    """Copy the erlang key from primary server to secondary"""
    # Copy the key from primary server to secondary
    command = "scp /var/lib/rabbitmq/.erlang.cookie root@%s:/var/lib/rabbitmq/.erlang.cookie" % \
                secondary_rabbitmq_server
    response = _send_command(command)
    print("Copy erlang key from primary host to secondary: %s" % response)

def _cluster_rabbitmq_servers(primary_rabbitmq_server, secondary_rabbitmq_server):
    """Perform the steps to cluster the rabbitmq servers"""
    command = "service rabbitmq-server restart"
    response = _send_command(command)
    print("Clustering rabbitmq, restarting server: %s" % response)

    command = "%s stop_app" % RABBITMQCTL
    response = _send_command(command)
    print("Clustering rabbitmq, stopping app: %s" % response)

    command = "nodeattr -v ha_pair | cut -f2 -d:"
    cluster_hostname = _send_command(command)
    print("Joining cluster: %s" % cluster_hostname)

    command = "%s join_cluster rabbit@%s" % \
                (RABBITMQCTL, cluster_hostname)
    response = _send_command(command)
    print("Clustering rabbitmq, joining cluster: %s" % response)

    command = "rabbitmqctl start_app"
    response = _send_command(command)
    print("Clustering rabbitmq, starting: %s" % response)

    # Print the status of the cluster
    command = "rabbitmqctl cluster_status"
    response = _send_command(command)
    print("Clustering rabbitmq, status: %s" % response)

def _create_ha_queues():
    """Mirror the ras_* queues between clustered rabbitmq servers"""
    command = "%s set_policy ha-all \"^ras_\" '{\"ha-mode\":\"all\"}'" % RABBITMQCTL
    response = _send_command(command)
    print("Mirroring queues in cluster: %s" % response)

def _send_command(command, fail_on_error=True):
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    response, error = process.communicate()
    if error is not None and \
       len(error) > 0:
        print("Running command: %s\n%s" % (command, error))
        if fail_on_error:
            sys.exit(1)
    return response

if __name__ == '__main__':
    main()
