#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
 ****************************************************************************
 Filename:          sspl_ll_d
 Description:       Entry point for the sspl-ll daemon service
 Creation Date:     01/14/2015
 Author:            Jake Abernathy

 Do NOT modify or remove this copyright and confidentiality notice!
 Copyright (c) 2001 - $Date: 2015/01/14 $ Seagate Technology, LLC.
 The code contained herein is CONFIDENTIAL to Seagate Technology, LLC.
 Portions are also trade secret. Any use, duplication, derivation, distribution
 or disclosure of this code, for any reason, not expressly authorized is
 prohibited. All other rights are expressly reserved by Seagate Technology, LLC.
 ****************************************************************************
"""

import logging
import signal
import getopt
import Queue
import fcntl
import time
import sys
import os

# Add the top level directories
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
os.sys.path.insert(0,parentdir)

from threading import Thread

from utils.config_reader import ConfigReader
from utils.service_logging import init_logging
from utils.service_logging import logger

# Modules for handling RabbitMQ messages and manipulating internal threads
from rabbitmq.rabbitmq_egress_processor import RabbitMQegressProcessor
from rabbitmq.rabbitmq_ingress_processor import RabbitMQingressProcessor

from framework.rabbitmq.plane_cntrl_rmq_egress_processor import PlaneCntrlRMQegressProcessor
from framework.rabbitmq.plane_cntrl_rmq_ingress_processor import PlaneCntrlRMQingressProcessor
from framework.base.sspl_constants import enabled_products

from rabbitmq.logging_processor import LoggingProcessor
from rabbitmq.thread_controller import ThreadController

from message_handlers.node_controller_msg_handler import NodeControllerMsgHandler
from message_handlers.node_data_msg_handler import NodeDataMsgHandler
from message_handlers.disk_msg_handler import DiskMsgHandler
from message_handlers.logging_msg_handler import LoggingMsgHandler
from message_handlers.service_msg_handler import ServiceMsgHandler
from message_handlers.plane_cntrl_msg_handler import PlaneCntrlMsgHandler
from message_handlers.real_stor_encl_msg_handler import RealStorEnclMsgHandler

# Message to send to HAlon upon critical thread errors
from json_msgs.messages.actuators.thread_controller import ThreadControllerMsg


# Section and key in config file for bootstrap
SSPL_SETTING    = 'SSPL-LL_SETTING'
CORE_PROCESSORS = 'core_processors'
MSG_HANDLERS    = 'message_handlers'
SENSORS         = 'sensors'
ACTUATORS       = 'actuators'

# Section containing information about the system we're running on
SYS_INFORMATION = 'SYSTEM_INFORMATION'
OPER_SYSTEM     = 'operating_system'
PRODUCT_NAME    = 'product'
SETUP           = 'setup'

# Instantiate the internal ThreadController. Global so the shutdown callback
#  method can use it to properly halt all running threads.
threadController = ThreadController()


def _dropPrivileges(user):
    """Remove root privileges to control possible access"""
    if os.getuid() != 0:
        return

    import prctl
    from pwd import getpwnam
    from grp import getgrnam

    altgroups = ('disk',)
    transition_caps = ('setuid', 'setgid')
    keep_caps = ('sys_rawio',)

    prctl.securebits.no_setuid_fixup = True

    prctl.cap_effective.limit(*transition_caps + keep_caps)
    prctl.cap_permitted.limit(*transition_caps + keep_caps)

    pw = getpwnam(user)
    os.setgid(pw.pw_gid)
    os.setuid(pw.pw_uid)

    os.setgroups([getgrnam(gname).gr_gid for gname in altgroups])

    prctl.cap_effective.drop(*transition_caps)
    prctl.cap_permitted.drop(*transition_caps)

def main(conf_reader, systemd_support):
    """The main bootstrap for sspl"""
    logger.info("sspl-ll Bootstrap: Obtaining list of modules from config file")

    # Create a map of references to all the module's message queues.  Each module
    #  is passed this mapping so that it can send messages to other modules.
    msgQlist = {}

    # Create a mapping of all the instantiated modules to their names
    sspl_threaded_modules = {}

    # Read in operating system value from configuration file
    operating_system = conf_reader._get_value(SYS_INFORMATION, OPER_SYSTEM)
    logger.info("sspl-ll Bootstrap: configuring for OS: %s" % operating_system)

    # Read in product value from configuration file
    product = conf_reader._get_value(SYS_INFORMATION, PRODUCT_NAME)

    # Read in setup value from configuration file
    try:
        setup = conf_reader._get_value(SYS_INFORMATION, SETUP)
    except Exception:
        setup = 'hw'

    logger.info("sspl-ll Bootstrap: setup=%s product=%s" % (setup, product))

    # CS-L/G systems run as root and we set capabilities on the process to control the access available to it
    if product not in enabled_products:
        _dropPrivileges("sspl-ll")

    # Use reflection to instantiate the classes based upon its class name in config file
    core_processors = conf_reader._get_value_list(SSPL_SETTING,
                                                  CORE_PROCESSORS)
    logger.info("sspl-ll Bootstrap: core processors to load: %s" % core_processors)
    for core_processor in core_processors:
        klass = globals()[core_processor]

        # Create mappings of modules and their message queues
        sspl_threaded_modules[klass.name()] = klass()
        msgQlist[klass.name()] = Queue.Queue()

    message_handlers = conf_reader._get_value_list(SSPL_SETTING,
                                                   MSG_HANDLERS)
    logger.info("sspl-ll Bootstrap: message handlers to load: %s" % message_handlers)

    for message_handler in message_handlers:
        klass = globals()[message_handler]

        # Create mappings of modules and their message queues
        sspl_threaded_modules[klass.name()] = klass()
        msgQlist[klass.name()] = Queue.Queue()

    # Instantiate the sensors and actuators

    sspl_threaded_modules, msgQlist = _sensors_actuators_factory(
                                            sspl_threaded_modules, msgQlist,
                                            operating_system, product, setup)

    # Add the ThreadConroller automatically
    msgQlist[ThreadController.name()] = Queue.Queue()

    try:
        # Loop through the list of instanced modules and start them on threads
        for name, curr_module in sspl_threaded_modules.iteritems():
            logger.info("Starting: %s" % curr_module.name())
            thread = Thread(target=_run_thread_capture_errors,
                            args=(curr_module, sspl_threaded_modules, msgQlist, conf_reader, product))
            thread.start()

        # Start the ThreadController module with the list of threads
        logger.info("Starting: %s" % ThreadController.name())

        # Initialize the thread controller with the list of references to all modules
        controller_thread = Thread(target=_run_thread_capture_errors,
                            args=(threadController, sspl_threaded_modules, msgQlist, conf_reader, product))
        threadController.initialize_thread_list(sspl_threaded_modules, operating_system, product, systemd_support)
        controller_thread.start()

        # Block main thread until thread controller has been halted
        controller_thread.join()

    except Exception as ex:
        logger.exception(ex)


# TODO: Create a factory class instead of a method
def _sensors_actuators_factory(sspl_threaded_modules, msgQlist, operating_system, product, setup):
    """Loops thru list of sensors/actuators and instantiate"""

    # Read in list of sensors
    sensors = conf_reader._get_value_list(SSPL_SETTING, SENSORS)
    logger.info("sspl-ll Bootstrap: sensors to load: %s" % sensors)

    # Read in list of actuators
    actuators = conf_reader._get_value_list(SSPL_SETTING, ACTUATORS)
    if setup in ['gw', 'cmu', 'vm'] and 'HPIactuator' in actuators:
        actuators.remove('HPIactuator')
    logger.info("sspl-ll Bootstrap: actuators to load: %s" % actuators)

    # Import in the proper classes based upon values from config file
    if operating_system == "centos7":
        from actuators.impl.centos_7.systemd_service import SystemdService as Service
        from actuators.impl.centos_7.command_line import CommandLine as CommandLine
        from actuators.impl.centos_7.systemd_login import SystemdLogin as Login
        from sensors.impl.centos_7.drive_manager import DriveManager as DriveManager
        from sensors.impl.centos_7.systemd_watchdog import SystemdWatchdog as ServiceWatchdog
        from sensors.impl.centos_7.hpi_monitor import HPIMonitor as HPIMonitor

    elif operating_system == "centos6":
        # Nothing yet
        pass

    elif operating_system in ["osX", "osx"]:
        from actuators.impl.os_x.xinitd_service import XinitdService as Service
        from actuators.impl.os_x.xinitd_login import XinitdLogin as Login
        from sensors.impl.os_x.drive_manager import DriveManager as DriveManager
        from sensors.impl.os_x.xinitd_watchdog import XinitdWatchdog as ServiceWatchdog
        from sensors.impl.os_x.hpi_monitor import HPIMonitor as HPIMonitor

    else:
        raise Exception("Operating System not supported")

    if product == "CS-A":
        from actuators.impl.generic.raritan_pdu import RaritanPDU
        from actuators.impl.generic.ipmi import IPMI
        if setup not in ['cmu', 'gw', 'vm']:
            try:
                from actuators.impl.generic.hpi_actuator import HPIactuator
            except ImportError:
                logger.info("Could not import HPIactuator")

        from sensors.impl.generic.SNMP_traps import SNMPtraps

    if product == "EES":
        from sensors.impl.platforms.realstor.realstor_disk_sensor \
        import RealStorDiskSensor
        from sensors.impl.platforms.realstor.realstor_psu_sensor \
        import RealStorPSUSensor
        from sensors.impl.platforms.realstor.realstor_fan_sensor \
        import RealStorFanSensor
        from sensors.impl.platforms.realstor.realstor_controller_sensor \
        import RealStorControllerSensor
        from sensors.impl.platforms.realstor.realstor_sideplane_expander_sensor \
        import RealStorSideplaneExpanderSensor
        from sensors.impl.platforms.realstor.realstor_logical_volume_sensor \
        import RealStorLogicalVolumeSensor

    if product in enabled_products:
        from actuators.impl.generic.raid import RAIDactuator
        from actuators.impl.generic.hdparm import Hdparm

        from sensors.impl.generic.raid import RAIDsensor
        from sensors.impl.generic.node_data import NodeData as NodeData
        from sensors.impl.generic.SMR_drive_data import SMRdriveData

        from zope.component import getGlobalSiteManager
        from zope.interface import implementedBy

        from zope.component import queryUtility
        from loggers.impl.iem_logger import IEMlogger

        # The Zope Global Site Manager containing objects that implement the desired interfaces
        gsm = getGlobalSiteManager()

    # Loop through the list of sensors/actuators and instantiate appropriately
    #  based upon whether or not it is threaded
    modules = sensors + actuators
    for module in modules:
        # Instantiate the class using reflection on the module's name; must match class name
        klass = locals()[module]

        # Look at module's configuration section and determine if it's threaded
        threaded = 'True'
        try:
            threaded = conf_reader._get_value(klass.name().upper(), 'threaded')
        except Exception as e:
            threaded = 'False'  # Wasn't present so default to False

        logger.info("Processing: %s, threaded: %s, Instantiated Class: %s"
                        % (module, threaded, klass.name()))

        # If it's threaded then add it to the list which will be handled by the ThreadController
        if threaded in ['True', 'true']:
            sspl_threaded_modules[klass.name()] = klass()
            msgQlist[klass.name()] = Queue.Queue()
        else:
            # It's a static non-threaded object, register it with the Zope global site manager
            interface_impl = list(implementedBy(klass))[0]  # Assumes single inheritance only
            logger.info("            Implements Interface: %s" % interface_impl.__name__)

            if product in enabled_products:
                gsm.registerUtility(klass, interface_impl)

    return (sspl_threaded_modules, msgQlist)


def _run_thread_capture_errors(curr_module, sspl_threaded_modules, msgQlist, conf_reader, product):
    """Run the given thread and log any errors that happen on it.
    Will stop all sspl_threaded_modules if one of them fails."""
    try:
        # Each module is passed a reference list to message queues so it can transmit
        #  internal messages to other modules as desired
        curr_module.initialize(conf_reader, msgQlist, product)
        curr_module.start()

    except Exception as ex:
        # Populate an actuator response message and transmit back to HAlon that we have a fatal error
        error_msg = "SSPL-LL encountered an error, terminating service Error, restarting daemon:{}" \
                    .format(str(logger.exception(ex)))
        jsonMsg   = ThreadControllerMsg(curr_module.name(), error_msg).getJson()
        curr_module._write_internal_msgQ(RabbitMQegressProcessor.name(), jsonMsg)

        # Shut down any running threads, error is non-recoverable
        shutdown_handler()

        # Pause for threads to cleanup and kill main process
        logger.info("Killing main process in 10 seconds to allow thread cleanup time")
        time.sleep(10)
        logger.info("Systemd will restart SSPL-LL momentarily")
        os.kill(os.getpid(), signal.SIGKILL)

def shutdown_handler(signum=None, frame=None):
    """Handler called when shutting down"""
    logger.info("sspl-ll is shutting down")

    shutdown_msg = "SSPL-LL is shutting down"
    jsonMsg   = ThreadControllerMsg(threadController.name(), shutdown_msg).getJson()
    threadController._write_internal_msgQ(RabbitMQegressProcessor.name(), jsonMsg)

    # Wait for the RabbitMQegressProcessor to finish processing
    # any messages which it may have in its queue
    while threadController.check_RabbitMQegressProcessor_is_running() is True:
        logger.info("Waiting for rabbitMQegress to finish sending queued msgs")
        time.sleep(2)

    # Now call the shutdown methods for all modules to gracefully halt
    threadController.shutdown_all_modules()

    # Halt the thread controller module last for a clean system shutdown
    threadController.shutdown()

    # Let systemd know that we've stopped successfully
    try:
        from systemd.daemon import notify
        notify("STOPPING=1")
    except Exception as ex:
        logger.info("sspl-ll is not using systemd, ignoring.")

def print_usage():
    """Display the syntax usage for this script"""
    print """sspl_ll_d -c <path_to_conf_file>
    -h:    Display this help
    -c:    Configuration settings for sspl_ll_d service"""


if __name__ == "__main__":
    # Retrieve configuration file for sspl-ll service
    try:
        opts = getopt.getopt(sys.argv[1:], "hc:", ["help", "config=", "systemd="])

    except getopt.GetoptError as err:
        print_usage()
        sys.exit(os.EX_USAGE)

    if len(opts[0]) < 1:
        print_usage()
        sys.exit(os.EX_USAGE)

    systemd_support = True
    for opt, arg in opts[0]:
        if opt == "-c" or opt == "--config":
            path_to_conf_file = arg
        elif opt == "-s" or opt == "--systemd":
            if arg == "False":
                systemd_support = False
        else:
            print_usage()
            sys.exit(os.EX_USAGE)

    # Validate configuration file for required valid values
    try:
        conf_reader = ConfigReader(path_to_conf_file)

    except (IOError, ConfigReader.Error) as err:
        # We don't have logger yet, need to find log_level from conf file first
        print "[ Error ] when validating the configuration file %s :" % \
            path_to_conf_file
        print err
        print "Exiting ..."
        sys.exit(os.EX_USAGE)

    # Initialize logging
    try:
        init_logging("SSPL-LL", "DEBUG")

    except Exception as err:
        # We don't have logger since it threw an exception, use generic 'print'
        print "[ Error ] when initializing logging :"
        print err
        print "Exiting ..."
        sys.exit(os.EX_USAGE)

    try:
        # Create a PID file for systemd
        if systemd_support:
            pidfile = "/var/run/sspl_ll/sspl_ll.pid"
            if os.path.isfile(pidfile):
                pid = file(pidfile).read()
                if len(pid) and os.path.exists("/proc/%s" % pid):
                    print "Another instance of SSPL with pid %s is active. exiting..." % pid
                    sys.exit(s.EX_OK)

            file(pidfile, "w").write(str(os.getpid()))

        # Start sspl-ll as a main process running multiple threads
        main(conf_reader, systemd_support)

    except (Exception, StandardError) as err:
        logger.critical("While spawning sspl-ll process :%r" % err)
        sys.exit(os.EX_USAGE)

    print "SSPL-LL Process started successfully"
    sys.exit(os.EX_OK)
