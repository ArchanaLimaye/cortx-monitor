#!/usr/bin/python3.6
"""
Setup rabbitmq for use by sspl_ll on EES systems

This script uses /etc/sspl.conf as the source of the parameters.

Usage:
    ./sspl_rabbitmq_reinit <product>
"""
import os
import subprocess
import sys
import socket

import pika

from configparser import ConfigParser
from config_reader import ConfigReader

RABBITMQCTL = '/usr/sbin/rabbitmqctl'
SSPL_CONF = '/etc/sspl.conf'
SECTION="RABBITMQEGRESSPROCESSOR"
INGRESS_CONFIG_SECTION = 'RABBITMQINGRESSPROCESSOR'
EGRESS_CONFIG_SECTION = 'RABBITMQEGRESSPROCESSOR'
LOGGER_CONFIG_SECTION = 'LOGGINGPROCESSOR'
CLUSTER_SECTION = 'RABBITMQCLUSTER'
ERLANG_COOKIE_PATH = '/var/lib/rabbitmq/.erlang.cookie'

EXCHANGE_NAME_KEY = 'exchange_name'
QUEUE_NAME_KEY = 'queue_name'
ROUTING_KEY = 'routing_key'
ACK_QUEUE_NAME_KEY = 'ack_queue_name'
ACK_ROUTING_KEY = 'ack_routing_key'
ACK_EXCHANGE_NAME_KEY = 'ack_exchange_name'
VIRT_HOST_KEY = 'virtual_host'
USER_NAME_KEY = 'username'
PASSWORD_KEY = 'password'

# Add the top level directories
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
os.sys.path.insert(0,parentdir)

from sspl_constants import cs_legacy_products, enabled_products

config_reader = ConfigReader(SSPL_CONF)

def main(product):
    """ Main line for this program. """
    config = ConfigParser()
    config.read([SSPL_CONF])

    virtual_host = config.get(
        section=SECTION,
        option='virtual_host'
        )
    username = config.get(
        section=SECTION,
        option='username'
        )
    password = config.get(
        section=SECTION,
        option='password'
        )

    if product in cs_legacy_products:
        primary_rabbitmq_server = config.get(
            section=SECTION,
            option='primary_rabbitmq_server'
            )
        secondary_rabbitmq_server = config.get(
            section=SECTION,
            option='secondary_rabbitmq_server'
            )
        _check_rabbitmq_status()
        _start_rabbitmq()

    # Always copy erlang cookie.
    copy_erlang_cookie()

    # Connect to cluster before creating user accounts.
    cluster_nodes = config_reader._get_value_list(
            CLUSTER_SECTION, 'cluster_nodes'
        )
    if len(cluster_nodes) > 1:
        cluster_rabbit_mq()
    else:
        print('RabbitMQ is running in single node mode.')

    _create_vhost_if_necessary(virtual_host, product)
    _create_user_if_necessary(username, password, virtual_host, product)

    # create durable/mirrored queues in either single or clustered mode.
    create_mirrored_queues()

    if product in cs_legacy_products:
        # Copy the erlang key from primary server to secondary and mirror queues
        if primary_rabbitmq_server in hostnames:
            _set_perms_erlang_key()
            _copy_erlang_key(secondary_rabbitmq_server)
            _create_ha_queues()

        # Cluster the secondary server to the primary
        elif secondary_rabbitmq_server in hostnames:
            _set_perms_erlang_key()
            _cluster_rabbitmq_servers(primary_rabbitmq_server, secondary_rabbitmq_server)


def copy_erlang_cookie():
    print('Creating erlang cookie...')
    command = 'systemctl stop rabbitmq-server'
    _send_command(command)
    # all rabbitmq servers needs to have same erlang cookie for clustering.
    cookie_value = config_reader._get_value(CLUSTER_SECTION, 'erlang_cookie')

    command = f'chmod +w {ERLANG_COOKIE_PATH}'
    _send_command(command)
    command = f'echo "{cookie_value}" > {ERLANG_COOKIE_PATH}'
    _send_command(command)
    command = f'chmod -w {ERLANG_COOKIE_PATH}'
    _send_command(command)
    command = 'systemctl start rabbitmq-server'
    _send_command(command)
    print('Done creating erlang cookie')


def create_mirrored_queues():
    print('Creating mirrored queues...')
    # creating actuator-req-queue queue.
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(INGRESS_CONFIG_SECTION)
    _set_ha_policy(queue_name)
    create_queue(vhost, username, password, exchange_name,
                 queue_name, routing_key)

    # creating sensor-queue queue
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(EGRESS_CONFIG_SECTION)
    _set_ha_policy(queue_name)
    create_queue(vhost, username, password, exchange_name,
                 queue_name, routing_key)

    # creating actuator-resp-queue queue
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(
            EGRESS_CONFIG_SECTION,
            exchange_key=ACK_QUEUE_NAME_KEY,
            queue_key=ACK_QUEUE_NAME_KEY,
            routing_key=ACK_ROUTING_KEY
        )
    _set_ha_policy(queue_name)
    create_queue(vhost, username, password, exchange_name,
                 queue_name, routing_key)

    # creating iem-queue queue
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(LOGGER_CONFIG_SECTION)
    _set_ha_policy(queue_name)
    create_queue(vhost, username, password, exchange_name,
                 queue_name, routing_key)
    print('Done creating mirrored queues...')


def _set_ha_policy(queue_name):
    print('Setting HA policy for queue {}'.format(queue_name))
    command = f'{RABBITMQCTL} set_policy -p SSPL ha-{queue_name} ' + \
              f'"^{queue_name}$" \'{{"ha-mode":"all"}}\''
    print(command)
    _send_command(command)


def _get_connection_config(section, exchange_key=EXCHANGE_NAME_KEY,
                           queue_key=QUEUE_NAME_KEY, routing_key=ROUTING_KEY):
    vhost = config_reader._get_value(section, VIRT_HOST_KEY)
    exchange_name = config_reader._get_value(section, exchange_key)
    queue_name = config_reader._get_value(section, queue_key)
    routing_key = config_reader._get_value(section, routing_key)

    username = config_reader._get_value(section, USER_NAME_KEY)
    password = config_reader._get_value(section, PASSWORD_KEY)
    return vhost, username, password, exchange_name, queue_name, routing_key


def create_queue(vhost, username, password, exchange_name, queue_name,
                 routing_key):
    creds = pika.PlainCredentials(username, password)
    connection = pika.BlockingConnection(
        pika.ConnectionParameters(
            host='localhost',
            credentials=creds,
            virtual_host=vhost,
        )
    )
    channel = connection.channel()
    try:
        channel.queue_declare(queue=queue_name, durable=True)
    except Exception as e:
        print('Exception in queue declaration: {}'.format(e))
    try:
        channel.exchange_declare(
            exchange=exchange_name,
            exchange_type='topic',
            durable=True,
        )
    except Exception as e:
        print('Exception is exchange declaration: {}'.format(e))
    channel.queue_bind(
        queue=queue_name,
        exchange=exchange_name,
        routing_key=routing_key
    )
    connection.close()


def cluster_rabbit_mq():
    print('Joining to RabbitMQ cluster...')
    nodes = config_reader._get_value_list(CLUSTER_SECTION, 'cluster_nodes')
    fqdn = socket.getfqdn().split('.')[0]
    clustered = False
    for node in nodes:
        if node != fqdn and not clustered:
            command = "%s stop_app" % RABBITMQCTL
            response = _send_command(command)
            print("Stopping app: %s" % response)
            command = f'{RABBITMQCTL} join_cluster rabbit@{node}'
            response = _send_command(command, fail_on_error=False)
            print(f"Join response: {response}")
            if 'Error:' in response:
                print(f'Unable to connect to {node} error: {response}')
                print('Re-trying another node...')
            else:
                clustered = True
            command = "rabbitmqctl start_app"
            response = _send_command(command)
            print("node started")
            break
    if clustered:
        print('Clustering was successful.')
    else:
        print('Not connected any node. Please check configuration.')


def _create_vhost_if_necessary(virtual_host, product):
    """ Creates the specified vhost (if necessary).

    No action will occur if the vhost already exists.

    @type virtual_host:           string
    @param virtual_host:          The vhost to create.
    @type product:                string
    @param product:               The product for which initialization is
                                  being done.
    """
    if product in cs_legacy_products:
        command = "%s list_vhosts" % RABBITMQCTL
        response = _send_command(command, fail_on_error=False)
        # Try restarting service
        if "Error" in response:
            command = "service rabbitmq-server restart"
            _send_command(command)
            command = "%s list_vhosts" % RABBITMQCTL
            response = _send_command(command)

        vhosts = response.split('\n')
        assert vhosts[0] == 'Listing vhosts ...'
        for vhost in vhosts[1:-1]:
            if vhost == virtual_host:
                return

        command = "%s add_vhost %s" % (RABBITMQCTL, virtual_host)
        _send_command(command)
        print("Successfully created vhost: %s" % virtual_host)

    elif product in enabled_products:
        vhosts = subprocess.check_output(
            [RABBITMQCTL, 'list_vhosts']
            ).decode("utf-8").split('\n')
        assert vhosts[0] == 'Listing vhosts ...'
        assert vhosts[-2] == '...done.'
        assert vhosts[-1] == ''
        for vhost in vhosts[1:-1]:
            if vhost == virtual_host:
                return
        subprocess.check_call([RABBITMQCTL, 'add_vhost', virtual_host])
    else:
        raise ValueError("Product should be one of: %s" % (cs_legacy_products + enabled_products))


def _create_user_if_necessary(username, password, virtual_host, product):
    """ Create the rabbitmq user (if necessary).

    The user is created (if it doesn't exist) and then set with .* permissions
    for conf,write,read on the specified virtual_host.

    The permissions will be set regardless of whether or not the user already exists.

    The password will only be set if this is a new user.

    Note: To delete the user, from bash, run::
        rabbitmqctl delete_user <username>

    @type username:               string
    @param username:              The user to create.
    @type password:               string
    @param passowrd:              The password for the specified user.  Will
                                  only be set if this is a new user.
    @type virtual_host:           string
    @param virtual_host:          The vhost on which the permissions will be
                                  set.
    @type product:                string
    @param product:               The product for which initialization is
                                  being done.
    """
    if product in cs_legacy_products:
        command = "%s list_users" % RABBITMQCTL
        response = _send_command(command)

        users = response.split("\n")
        assert users[0] == 'Listing users ...'
        found_user = False
        for userspec in users[1:-1]:
            user = userspec.split()[0]
            if user == username:
                found_user = True
                break
        if not found_user:
            # Create the user and set permissions, will exit upon error
            command = "%s add_user %s %s" % (RABBITMQCTL, username, password)
            _send_command(command)
            command = "%s set_permissions -p %s %s '.*' '.*' '.*'" % (RABBITMQCTL, virtual_host, username)
            _send_command(command)
            command = "%s set_user_tags %s administrator" % (RABBITMQCTL, username)
            _send_command(command)
    elif product in enabled_products:
        users = subprocess.check_output(
            [RABBITMQCTL, 'list_users']
            ).decode("utf-8").split('\n')
        assert users[0] == 'Listing users ...'
        assert users[-2] == '...done.'
        assert users[-1] == ''
        found_user = False
        for userspec in users[1:-1]:
            user = userspec.split()[0]
            if user == username:
                found_user = True
                break
        if not found_user:
            subprocess.check_call([RABBITMQCTL, 'add_user', username, password])
        subprocess.check_call(
            [
                RABBITMQCTL, 'set_permissions',
                '-p', virtual_host,
                username, '.*', '.*', '.*'
            ])
        subprocess.check_call(
            [RABBITMQCTL, 'set_user_tags', username, 'administrator']
            )
    else:
        raise ValueError("Product should be one of: %s" % (cs_legacy_products + enabled_products))

def _check_rabbitmq_status():
    """Reset if the node is down"""
    command = "service rabbitmq-server status"
    response = _send_command(command)
    if "nodedown" in response:
        print("Nodedown, resetting")
        command = "pkill beam.smp"
        _send_command(command)

def _start_rabbitmq():
    """Ensure rabbitmq-server is started"""
    command = "service rabbitmq-server start"
    _send_command(command)

def _set_perms_erlang_key():
    # Set the ownership and permissions on cluster key
    command = "chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie"
    _send_command(command)
    command = "chmod 400 /var/lib/rabbitmq/.erlang.cookie"
    _send_command(command)

def _copy_erlang_key(secondary_rabbitmq_server):
    """Copy the erlang key from primary server to secondary"""
    # Copy the key from primary server to secondary
    command = "scp /var/lib/rabbitmq/.erlang.cookie root@%s:/var/lib/rabbitmq/.erlang.cookie" % \
                secondary_rabbitmq_server
    response = _send_command(command)
    print("Copy erlang key from primary host to secondary: %s" % response)

def _cluster_rabbitmq_servers(primary_rabbitmq_server, secondary_rabbitmq_server):
    """Perform the steps to cluster the rabbitmq servers"""
    command = "service rabbitmq-server restart"
    response = _send_command(command)
    print("Clustering rabbitmq, restarting server: %s" % response)

    command = "%s stop_app" % RABBITMQCTL
    response = _send_command(command)
    print("Clustering rabbitmq, stopping app: %s" % response)

    command = "nodeattr -v ha_pair | cut -f2 -d:"
    cluster_hostname = _send_command(command)
    print("Joining cluster: %s" % cluster_hostname)

    command = "%s join_cluster rabbit@%s" % \
                (RABBITMQCTL, cluster_hostname)
    response = _send_command(command)
    print("Clustering rabbitmq, joining cluster: %s" % response)

    command = "rabbitmqctl start_app"
    response = _send_command(command)
    print("Clustering rabbitmq, starting: %s" % response)

    # Print the status of the cluster
    command = "rabbitmqctl cluster_status"
    response = _send_command(command)
    print("Clustering rabbitmq, status: %s" % response)

def _create_ha_queues():
    """Mirror the ras_* queues between clustered rabbitmq servers"""
    command = "%s set_policy ha-all \"^ras_\" '{\"ha-mode\":\"all\"}'" % RABBITMQCTL
    response = _send_command(command)
    print("Mirroring queues in cluster: %s" % response)

def _send_command(command, fail_on_error=True):
    print(f'Executing: {command}')
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    response, error = process.communicate()
    if error is not None and \
       len(error) > 0:
        print("command '%s' failed with error\n%s" % (command, error))
        if fail_on_error:
            sys.exit(1)
        else:
            return str(error)
    return str(response)


if __name__ == '__main__':
    product = sys.argv[1]
    main(product)
