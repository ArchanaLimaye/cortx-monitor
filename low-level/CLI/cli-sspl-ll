#!/usr/bin/env python 
# encoding: utf-8
"""
 Filename:          cli-sspl-ll
 Description:       CLI to send msgs to SSPL-LL service
 Creation Date:     12/02/2015
 Author:            Jake Abernathy

 Do NOT modify or remove this copyright and confidentiality notice!
 Copyright (c) 2001 - $Date: 2015/01/14 $ Seagate Technology, LLC.
 The code contained herein is CONFIDENTIAL to Seagate Technology, LLC.
 Portions are also trade secret. Any use, duplication, derivation, distribution
 or disclosure of this code, for any reason, not expressly authorized is
 prohibited. All other rights are expressly reserved by Seagate Technology, LLC.
"""

import sys
import os
import re
import json
import time
from json import JSONDecoder

# Add the top level directories
sys.path.insert(0, '..')
from framework.utils.config_reader import ConfigReader
from tests.manual.manual_test import ManualTest

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

__all__ = []
__version__ = 0.1
__date__ = '2015-12-02'
__updated__ = '2015-12-02'

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# Create instance of ManualTest to publish messages
manTest = ManualTest("RABBITMQEGRESSPROCESSOR")    

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg

    def __str__(self):
        return self.msg

    def __unicode__(self):
        return self.msg

def main():
    '''CLI to send msgs to SSPL-LL service'''

    # Display help if no args are passed in
    if len(sys.argv) == 1:
        sys.argv.append("--help")

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)
    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    description = "Program for interacting with SSPL-LL service"

    try:
        # Setup argument parser
        parser = ArgumentParser(description=description, formatter_class=RawDescriptionHelpFormatter, add_help=False)
        parser.add_argument("-v", "--version", action="version", version=program_version_message)
        parser.add_argument("-a", "--all", action="store_true", help="show all the data received in responses")
        parser.add_argument("-h", "--human", action="store_true", help="show responses with indentation for readability")
        parser.add_argument("--help", action="store_true", help="show this help message and exit")
        parser.add_argument("--pdu", metavar="COMMAND", help="send command to PDU. \
                              ie 'show outlets details'")
        parser.add_argument("--resetdrive", metavar="DRIVE", help="reset drive by cycling its power.  ie /dev/sda1")
        parser.add_argument("--smart", metavar="DRIVE", help="show SMART results for a drive. ie /dev/sda1 or '*'")
        parser.add_argument("--drvmngr", metavar="DRIVE", help="show drivemanager's status. ie /dev/sda1 or '*'")
        parser.add_argument("--hpi", metavar="DRIVE", help="show HPI status. ie /dev/sda1 or '*'")
        parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
        parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
        parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
        parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
        parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
        parser.add_argument("--hdparm", metavar="COMMAND", help="ie \"-I /dev/sda | grep 'Serial Number:'\"")
        parser.add_argument("--logiem", metavar="MESSAGE", help="log IEM message.  ie 'IEC: 001002001: Rules Engine...'")
        parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")

        group = parser.add_mutually_exclusive_group()
        group.add_argument("--smrdata", action="store_true", help="log SMR drive register data")
        group.add_argument("--cpudata", action="store_true", help="show CPU data")
        group.add_argument("--hostdata", action="store_true", help="show host data")
        group.add_argument("--mountdata", action="store_true", help="show local mount data")
        group.add_argument("--interfacedata", action="store_true", help="show network interface data")
        group.add_argument("--raiddata", action="store_true", help="show RAID data")

        parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
        parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")

        # Process arguments
        args = parser.parse_args()

        if args.help:
            parser.print_help()

        elif args.pdu:
            # Load a PDU message from the manual tests directory and update it with args.pdu
            file = "../tests/manual/actuator_msgs/node_cntrl_pdu.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"PDU: {}".format(args.pdu)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.resetdrive:
            # Load a reset drive message from the manual tests directory and update it with args.resetdrive
            file = "../tests/manual/actuator_msgs/node_cntrl_pdu.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"RESET_DRIVE: {}".format(args.resetdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.smart:
            # Load a smart test message from the manual tests directory and update it with args.smart
            file = "../tests/manual/actuator_msgs/node_cntrl_smart_test.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SMART_TEST: {}".format(args.smart)

            wait_time = 3
            if "*" in str(args.smart):
                wait_time = 20
    
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time)

        elif args.drvmngr:
            # Load a drivemanager status message from the manual tests directory and update it with args.drvmngr
            file = "../tests/manual/actuator_msgs/node_cntrl_drvmngr_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"DRVMNGR_STATUS: {}".format(args.drvmngr)

            wait_time = 3
            if "*" in str(args.smart):
                wait_time = 20

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time)

        elif args.hpi:
            # Load a reset hpi status message from the manual tests directory and update it with args.hpi
            file = "../tests/manual/actuator_msgs/node_cntrl_drvmngr_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"HPI_STATUS: {}".format(args.hpi)
            
            wait_time = 3
            if "*" in str(args.smart):
                wait_time = 20
            
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time)

        elif args.restartthread:
            # Load a restart thread message from the manual tests directory and update it with args.restartthread
            file = "../tests/manual/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = u"{}".format(args.restartthread)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.servicename or args.servicereq:
            if not args.servicename:
                print("Error: must provide a service name to apply request using --servicename NAME")
                return

            if not args.servicereq:
                print("Error: must provide a request to apply to the service using --servicereq REQUEST")
                print("       where REQUEST must be one of: start/stop/restart/status/enable/disable")
                return

            if args.servicereq not in ['start', 'stop', 'restart', 'status', 'enable', 'disable']:
                print("Error: Service request must be one of: start/stop/restart/status/enable/disable")
                return

            if ".service" not in args.servicename:
                args.servicename += ".service"

            # Load a service controller message from the manual tests directory and update it with args.servicename & servicereq
            file = "../tests/manual/actuator_msgs/service_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_name"] = u"{}".format(args.servicename)
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_request"] = u"{}".format(args.servicereq)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.ipmicmd or args.ipmiIP:
            if not args.ipmiIP:
                print("Error: must provide an IP to apply using --ipmiIP IP")
                return

            if args.ipmicmd not in ['on', 'off', 'cycle', 'status']:
                print("Error: IPMI command must be one of: on/off/cycle/status")
                return

            # Load a IPMI command message from the manual tests directory and update it with args.ipmicmd & ipmiIP
            file = "../tests/manual/actuator_msgs/node_cntrl_ipmi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"IPMI: {} {}". \
                                    format(args.ipmiIP, args.ipmicmd)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.hdparm:
            # Load a hdparm message from the manual tests directory and update it with args.hdparm
            file = "../tests/manual/actuator_msgs/node_cntrl_hdparm.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"HDPARM: {}".\
                                    format(args.hdparm)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.logiem or args.iemloglevel:
            if not args.logiem:
                print("Error: must provide an IEM message using --logiem MESSAGE")
                return
 
            if not args.iemloglevel:
                print("Error: must provide a log level to apply using --iemloglevel LEVEL")
                print("       where LEVEL is one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,") 
                print("                              LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if args.iemloglevel not in ['LOG_EMERG', 'LOG_ALERT', 'LOG_CRIT', 'LOG_ERR', \
                                        'LOG_WARNING', 'LOG_NOTICE', 'LOG_INFO', 'LOG_DEBUG']:
                print("Error: IEM log level must be one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, ")
                print("                                  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            # Load a logging message from the manual tests directory and update it with args.logiem
            file = "../tests/manual/actuator_msgs/logging.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["logging"]["log_level"] = u"{}".\
                                    format(args.iemloglevel)
            jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = u"{}".\
                                    format(args.logiem)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.smrdata:
            # Load a restart thread message from the manual tests directory and update it with SMRdriveData
            file = "../tests/manual/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = u"SMRdriveData"
            _send_raw_msg(jsonMsg, wait_for_response=False, alldata=args.all, indent=args.human)
            print("Check logs for new SMR drive register values")

        elif args.cpudata:
            # Load a sensor request message for cpu data from the manual tests directory and send it in
            file = "../tests/manual/actuator_msgs/sensor_request_cpu_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.hostdata:
            # Load a sensor request message for host data from the manual tests directory and send it in
            file = "../tests/manual/actuator_msgs/sensor_request_host_update.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.mountdata:
            # Load a sensor request message for local mount data from the manual tests directory and send it in
            file = "../tests/manual/actuator_msgs/sensor_request_mount_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.interfacedata:
            # Load a sensor request message for network data from the manual tests directory and send it in
            file = "../tests/manual/actuator_msgs/sensor_request_if_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.raiddata:
            # Load a sensor request message for raid data from the manual tests directory and send it in
            file = "../tests/manual/actuator_msgs/sensor_request_raid_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.fromstdin:
            print("Ctrl-D stop reading from stdin and transmit.  Multiple msgs can be piped in.")
            json_txt = ""
            try:
                json_txt = sys.stdin.read()
            except KeyboardInterrupt:
                pass

            if not json_txt:
                return 0

            # Load in a multiple json msgs possibly sent in from stdin
            json_list = []
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=WHITESPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        elif args.fromfile:
            # Load in a multiple json msgs stored in a single file
            json_list = []
            json_txt = open(args.fromfile).read()
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=WHITESPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        return 0
    except KeyboardInterrupt:
        return 0
    except Exception, e:
        print("Exception:{}".format(e))
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

def _send_raw_msg(jsonMsg, wait_for_response=True, response_wait_time=3,
                  alldata=False, indent=False, remove_results_file=True):
    """Update authentication fields, validate and transmit json msg"""

    # Update the authentication fields in json msg
    manTest.addAuthFields(jsonMsg)

    # Validate the msg against the schemas
    manTest.validate(jsonMsg)

    # Encode and publish
    message = json.dumps(jsonMsg, ensure_ascii=True).encode('utf8')
    manTest.basicPublish(message=message, wait_for_response=wait_for_response, 
                         response_wait_time=response_wait_time,
                         alldata=alldata, indent=indent,
                         remove_results_file=remove_results_file)

if __name__ == "__main__":
    sys.exit(main())